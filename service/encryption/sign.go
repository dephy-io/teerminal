package encryption

import (
	"fmt"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	"github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
	"github.com/ethereum/go-ethereum/crypto"
	"teerminal/config"
	"teerminal/constants"
)

func Sign(key []byte, data []byte) ([]byte, error) {
	private := secp256k1.PrivKeyFromBytes(key)
	if private == nil {
		return nil, constants.ErrorFailedDecodePrivateKey
	}
	hash := crypto.Keccak256(data)
	sig := ecdsa.SignCompact(private, hash, false)
	v := sig[0]
	copy(sig, sig[1:])
	sig[len(sig)-1] = v
	return sig, nil
}

func DerivePrivateKey(key []byte, derivation []byte) (derived []byte) {
	// Derive key: keccak256(key || b"_derive_" || derivation_path)
	// First left pad derivation path to 32 bytes
	derivationPath := make([]byte, 32)
	copy(derivationPath, derivation)
	// Convert derivation prefix to bytes
	derivationPrefix := []byte(constants.DerivationPrefix)
	// Concatenate key, derivation prefix and derivation path
	concatenated := append(key, derivationPrefix...)
	concatenated = append(concatenated, derivationPath...)
	// Hash the concatenated data
	derived = crypto.Keccak256(concatenated)
	return
}

func GetPublicKey(key []byte) (publicKey []byte) {
	// Get public key from private key
	private := secp256k1.PrivKeyFromBytes(key)
	public := private.PubKey()
	publicKey = public.SerializeUncompressed()
	// Remove first byte (0x04)
	publicKey = publicKey[1:]
	return
}

func GenerateCert(prover []byte, derivation []byte) (cert []byte) {
	// Certificates are generated by hashing the prover's public key and the child's public key
	// Format: keccak256(derivation_seed || public_key(64bit format))
	// Result Format: 64bit parent public key || 64bit child public key || 32bit derivation_seed || 65bit signature
	derivationBuffer := make([]byte, 32)
	copy(derivationBuffer, derivation)
	derived := DerivePrivateKey(prover, derivationBuffer)
	// Get public key from derived private key
	derivedPrivate := secp256k1.PrivKeyFromBytes(derived)
	derivedPublic := derivedPrivate.PubKey()
	// Convert public key to bytes
	derivedPublicKey := derivedPublic.SerializeUncompressed()
	// Remove first byte (0x04)
	derivedPublicKey = derivedPublicKey[1:]
	// Concatenate derivation seed and public key
	concatenated := append(derived, derivedPublicKey...)
	// Sign the certificate
	sig, _ := Sign(prover, concatenated)
	// Get Patent Public Key
	proverPublic := secp256k1.PrivKeyFromBytes(prover).PubKey()
	proverPublicKey := proverPublic.SerializeUncompressed()
	proverPublicKey = proverPublicKey[1:]
	// Add 64 bytes public key to the certificate
	cert = append(cert, proverPublicKey...)
	cert = append(cert, derivedPublicKey...)
	// Add 32 bytes derivation seed to the certificate
	cert = append(cert, derivationBuffer...)
	// Add 65 bytes signature to the certificate
	cert = append(cert, sig...)

	return
}

func VerifySignature(pubKey []byte, data []byte, signature []byte) bool {
	// Verify the signature
	hash := crypto.Keccak256(data)
	// Sub 27 if v is 27 or 28
	sig := make([]byte, len(signature))
	copy(sig, signature)
	if sig[len(sig)-1] >= 27 {
		sig[len(sig)-1] -= 27
	}
	// Add 0x04 prefix to public key
	pubKeyWithPrefix := append([]byte{0x04}, pubKey...)
	public, err := secp256k1.ParsePubKey(pubKeyWithPrefix)
	if err != nil {
		return false
	}
	rec, _, err := ecdsa.RecoverCompact(sig, hash)
	if err != nil {
		fmt.Printf("encryption.VerifySignature: %v\n", err)
		return false
	}
	return public.IsEqual(rec)
}

func GetDeviceRootCert() (cert []byte) {
	// Root Certificate is generated by the same rules as the child certificate, except the derivation seed is fixed to 0
	prover := config.GetVendorRoot()
	derivation := make([]byte, 32)
	derived := config.GetRootKey()
	derivedPrivate := secp256k1.PrivKeyFromBytes(derived)
	derivedPublic := derivedPrivate.PubKey()
	derivedPublicKey := derivedPublic.SerializeUncompressed()
	derivedPublicKey = derivedPublicKey[1:]
	concatenated := append(derived, derivedPublicKey...)
	sig, _ := Sign(prover, concatenated)
	proverPublic := secp256k1.PrivKeyFromBytes(prover).PubKey()
	proverPublicKey := proverPublic.SerializeUncompressed()
	proverPublicKey = proverPublicKey[1:]
	cert = append(cert, proverPublicKey...)
	cert = append(cert, derivedPublicKey...)
	cert = append(cert, derivation...)
	cert = append(cert, sig...)
	return
}
